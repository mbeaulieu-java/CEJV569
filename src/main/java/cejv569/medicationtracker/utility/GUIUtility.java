package cejv569.medicationtracker.utility;


import cejv569.medicationtracker.MedTrack;
import javafx.event.EventType;
import javafx.fxml.FXMLLoader;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Control;
import javafx.scene.control.Labeled;
import javafx.scene.control.TextInputControl;
import javafx.scene.image.Image;
import javafx.scene.layout.*;
import javafx.stage.Stage;

import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

/**
 * GUIUtility is a class with static methods and is used as a utility class to encapsulate
 * GUI related processing that is related to visual aspects of the app.  Generally, this involves
 * setting properties on controls change their behavior or appearance to provide feedback
 * to the user.  It can also be used to encapsulate the process of opening app forms or loading
 * background images of controls.
 */

public class GUIUtility {

   //GUI Constants related to setting color properties of different controls

   public static final String DEFAULT_ERROR_FIELD_BORDER_COLOR = "RED";
   public static  final String DEFAULT_FIELD_BORDER_COLOR = "LIGHTGREY";
   public static  final String DEFAULT_FIELD_TEXTFILL_COLOR = "BLACK";
    public static  final String DEFAULT_ERROR_FIELD_TEXTFILL_COLOR = "RED";

    private GUIUtility() {}

    /**
     * openPane is used across the application to load and display various forms.  It avoids
     * some code duplication linked to this process.
     * @param aStage - Stage type - the main stage of the application received at start() in the app
     *                              entry point controller.
     * @param filePath -String type - the path to the fxml file resource to be loaded by the fxmlLoader.
     * @param userData  0bject type - any custom object to be passed to the scene or one of it's children
     *                              via it's userData attribute.
     * @throws IOException  - exception that can be generated by the fxmlLoader
     */
    public static void openPane(Stage aStage, String filePath, Object userData) throws IOException {

        //load the fxml file for the form
        FXMLLoader fxmlLoader = new FXMLLoader(MedTrack.class.getResource(filePath));
        Scene scene = new Scene(fxmlLoader.load());

        //initialize the userData property of the scene, if requires custom data to be trans
        //-fered to it.  Is null by default.
        scene.setUserData(userData);
        aStage.setTitle("MedTrack");
        aStage.setScene(scene);
        aStage.centerOnScreen();
        aStage.showAndWait();
    }

    /**
     * getBackgroundImage is used to load background images into various controls, by multiple
     * entities in the app.  For example, most app buttons contain graphics.  This function will
     * be used for these types of instances.  The function receives the current class as aClass and
     * creates a new Image instance by loading the required image file using the imagePath.
     * It then crates a new BackgroundImage instance, passing it the Image instance created.
     * After which, it initializes parameters of how the image is to appear in the control.  Since the
     * image is used as a background, the background doesn't repeat, is centered and sizes to
     * the control without exceeding it's bounds (contain vs. cover).  Finally, it creates a new
     * Background object, initializes it with the new BackgroundImage created and returns the background.
     * @param aClass - Class type - The current running class
     * @param imagePath - String tyoe - path to the image file resource
     * @return - Background type - a background instance that has been initialized with the requested
     *                              image and initialized so that the image appears formated as a background for the
     *                                  control to which it will be applied.
     */
    public static Background getBackgroundImage(Class aClass,String imagePath) {
        Image image = new Image(aClass
                .getResource(imagePath)
                .toExternalForm());

        BackgroundImage bckImage = new BackgroundImage(image, BackgroundRepeat.NO_REPEAT,
                BackgroundRepeat.NO_REPEAT, BackgroundPosition.CENTER,
                new BackgroundSize(BackgroundSize.AUTO,BackgroundSize.AUTO, false,
                        false, true, false));
        return new Background(bckImage);
    }

    /**
     * ClearAllInputTextFields clears all controls of type TextInputControl on a given container.
     * It receives the container as a Pane object.  Generally used to re-initialize text fields of a
     * form after text was previously entered in them.
     * @param theParent  - Pane type - generally the top level control containing the TextInputControls.
     */

    public static void clearAllInputTextFields(Pane theParent) {
        //loop through the children controls of the Pane.
        for (Node c: theParent.getChildren()) {
            //if the child is of a type that extends TextInputControl (such as a TextField) set it's content
            // to empty.
            if (c instanceof TextInputControl) {
                ((TextInputControl)c).setText("");
            }
        }
    }

    /**
     * signalEmptyField can be used by any forms in the app that require text to be input by the
     * user, where certain fields cannot be left blank, since the information is required by the application.
     * In these cases, the form can create a list of TextInputControls that are "required fields". ie.
     * that cannot be left blank.  It can then pass this list to signalEmptyField so that
     * it can handle validating which fields have been left blank and how to signal this to the user.
     * The function loops through the provided list and any empty controls have their border
     * changed to red, the focus of the app set to it (if it is the first control empty in the list) and
     * it's text is highlighted.  An error message whose fill-text is set to red is also displayed
     * informing the user that the field(s) cannot be left blank.  Empty controls are added to
     * a list for group processing.  If the control is not empty, it's border is set back to it's default color.
     * If there are no empty controls, that is the areEmotyControls list is empty, then the label
     * used to display messages to the user is returned to is default color and set to be invisible.
     *
     * @param controls - List<TextInputControl> - a list of TextInputControls created by any view controller
     *                                    that has a form containing textfields that are required to be filled
     *                                  by the user.
     * @param emptyBorderColor  String - One of the constant values to be found at the top
     *                                  of this class, specifying the error color of the textinput controls'
     *                                  borders.
     * @param defaultBorderColor - String -  One of the constant values to be found at the top
     *      *                                  of this class, specifying the original color of the textinput controls'
     *      *                                  borders.
     * @param messageControl - Labeled - any control that extends the Labeled class that is used to display
     *                      an error to the user, such as a label.
     * @param messageDefaultColor - String -  One of the constant values to be found at the top
     *                                     of this class, specifying the original/default
     *                                      color of the textinputcontrols' text.
     *
     * @param messageEmptyColor - String - One of the constant values to be found at the top
     *                                      of this class, specifying the original/default
     *                                       color of the textinputcontrols' text.
     *
     * @param message - String -        error message string to advise that fields can't be left
     *                                  blank, to be found in the UserMessages utility class ErrorMessages enum.
     * @return  boolean -               true if any empty controls were found, false if none
     */
    public static boolean signalEmptyField(List<TextInputControl> controls,
                                           String emptyBorderColor,
                                           String defaultBorderColor,
                                           Labeled messageControl,
                                           String messageDefaultColor,
                                           String messageEmptyColor,
                                           String message) {


        List<TextInputControl> areEmptyControls = new ArrayList<TextInputControl>();
        for (TextInputControl c : controls) {
                if (c.getText().isBlank()) {
                   c.setStyle("-fx-border-color: " + emptyBorderColor + ";");
                   c.addEventHandler(EventType.ROOT,e->{
                        if(!c.getText().isBlank()) {
                            undoDisplayFieldError(c,messageControl);
                        } else {
                            displayFieldError(c,messageControl,UserMessages.ErrorMessages.BLANK_ERROR_MESSAGE.message);
                        }
                   });
                   areEmptyControls.add(c);
                } else {
                  //  c.setStyle("-fx-border-color: " + defaultBorderColor + ";");
                }
            }

        for (TextInputControl c : areEmptyControls) {
                c.selectAll();
                c.requestFocus();
                break;
        }

        if (!areEmptyControls.isEmpty()) {
            messageControl.setText(message);
            messageControl.setStyle("-fx-text-fill: " + messageEmptyColor + ";");
            messageControl.setVisible(true);
        } else {
            messageControl.setText("");
            messageControl.setStyle("-fx-text-fill: " + messageDefaultColor +  ";");
            messageControl.setVisible(false);
        }

        return !areEmptyControls.isEmpty();
    }

    /**
     * displayFieldError is used by the app to change the display properties of a textinputcontrol
     * in cases where the input control is not just empty, but where the data the user entered
     * might be incorrect in some way.  It thus sets the control's borders to red and the text
     * of the message label field it receives to red and makes sure that the message is made visible
     * to the user.
     * @param field -TextInputControl - The TextInput field that has invalid data entered in it
     * @param msgLabel - Labeled - The control that is being used to display error messages to the
     *                 user.
     * @param message   - String - the message from the UserMessasages class child ErrorMessages enum class.
     */
    public static void displayFieldError(TextInputControl field, Labeled msgLabel, String message) {
        field.requestFocus();
        field.selectAll();
        field.setStyle("-fx-border-color: " + DEFAULT_ERROR_FIELD_BORDER_COLOR +  ";");
        msgLabel.setText(message);
        msgLabel.setStyle("-fx-text-fill: " + DEFAULT_ERROR_FIELD_TEXTFILL_COLOR +  ";");
        msgLabel.setVisible(true);
    }

    /**
     * undoDisplayFieldError, overloaded method,  resets any changes performed on a field by displayFieldError, setting the
     * control's border back to it's default color, resetting the text color for the error message
     * label and making the label invisible.
     * @param field - TextInputControl - a control to which visual changes were applied by displayFieldError.
     *                                  For which we want to remove the visual effects from.
     * @param msgLabel   - Labeled type  - the Labeled child class control used to display
     *                                  error messages to the user.
     */
    public static void undoDisplayFieldError (TextInputControl field, Labeled msgLabel) {
        field.setStyle("-fx-border-color: " + DEFAULT_FIELD_BORDER_COLOR +  ";");
        msgLabel.setText("");
        msgLabel.setStyle("-fx-text-fill: " + DEFAULT_FIELD_TEXTFILL_COLOR +  ";");
        msgLabel.setVisible(false);
    }

    /**
     *  undoDisplayFieldError is an overloaded method, performs the same actions as what
     *  undoDisplayError does for a single TextFieldInput control but instead to each
     *  of the members of a list of TextInputControls.
     *
     * @param fields - List<TextInputControl> - a list of controls to which visual changes were applied by displayFieldError.
     *                                           For which we want to remove the visual effects from.
     * @param msgLabel  - Labeled type  - the Labeled child class control used to display
     *                                     error messages to the user.
     */
    public static void undoDisplayFieldError (List<TextInputControl> fields, Labeled msgLabel) {

        //get the list as a stream and return each item in the stream to it's default
        // original border color
        Stream<TextInputControl> fieldStream = fields.stream();

        fieldStream.forEach(f -> {f.setStyle("-fx-border-color: "
                + DEFAULT_FIELD_BORDER_COLOR +  ";");});

        //reset error message label back to default text color
        msgLabel.setText("");
        msgLabel.setStyle("-fx-text-fill: " + DEFAULT_FIELD_TEXTFILL_COLOR +  ";");
        msgLabel.setVisible(false);
    }

    public static void makeUnEditable(List<Control> controlList)
            throws InvocationTargetException,IllegalAccessException,NoSuchMethodException{
        for (Control c: controlList) {
            Class cls = c.getClass();
            Method[] methods =  cls.getMethods();
            for(Method m : methods) {
                if (m.getName().trim().equalsIgnoreCase("setEditable")) {
                    m.invoke(c,false);
                    break;
                }
            }
        }
    }

    public static void makeEditable(List<Control> controlList)
            throws InvocationTargetException,IllegalAccessException,NoSuchMethodException{
        for (Control c: controlList) {
            Class cls = c.getClass();
            Method[] methods =  cls.getMethods();
            for(Method m : methods) {
                if (m.getName().trim().equalsIgnoreCase("setEditable")) {
                    m.invoke(c,true);
                    break;
                }
            }
        }
    }
}
